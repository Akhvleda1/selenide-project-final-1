# Strategy & Reasoning

## Why Automate This?
**E2E სცენარი - ბანკის ვალუტის კურსის გადამოწმება:**
- **Risk:** თუ სცენარი დაფეილდება და არ იმუშავებს, მომხმარებლებს არ ექნებათ შესაძლებლობა ნახონ 
ბანკში არსებული ვალუტის ყიდვის და გაყიდვის კურსი, რაც გამოიწვევს არასწორ გადაწყვეტილებებს 
და მომხმარებლების დაბნეულობას.
- **Business value:** აღნიშნული ფუნქციონალის დახმარებით, მომხმარებლებს შეუძლიათ მარტივად შეამოწმონ 
სხვადასხვა ვალუტის კურსი, შესაბამისად გაიზრდება მათ ინტერესი გადაცვალონ ვალუტა ბანკში, რაც გამოიწვევს 
ბანკის შემოსავლების გაზრდას.
- **UI automation:** ავტომატიზაცია გვეხმარება ძალიან მცირე დროში გადავამოწმოთ აღნიშნული ფუნქციონალის 
გამართულობა.

**E2E სცენარი - გაფილტრული შეთავაზებების ნახვა**
- **Risk:** სცენარის დაფეილების შემთხვევაში, მომხმარებლები არ ექნებათ შესაძლებლობა მარტივად ნახონ
ახალი ბარათის შეთავაზებები
- **Business value:** ფუნქციონალის საშუალებით, მომხმარებლებს შეუძლიათ მარტივად მოძებნონ და აარჩიონ
სასურველი შეთავაზებები, რაც გამოიწვევს მეტი ახალი ბარათის დამზადებას და გამოყენებას.
- **UI automation:** ავტომატიზაციის დახმარებით ჩვენ მარტივად შევძლებთ UX-ის გავლას მათი პერსპექტივიდან. 

**E2E სცენარი - სამომხმარებლო სესხის კალკულატორი**
- **Risk:** ტესტის დაფეილების შემთხვევაში, მომხმარებლებს არ ექნებათ შესაძლებლობა გამოითვალონ სასურველი თანხის
სესხის ყოველთვიური შენატანი, რის გამოც შეიძლება ვერ მიიღონ გადაწყვეტილება სესხის აღების შესახებ.
- **Business value:** ფუნქციონალის დახმარებით, მომხმარებლებს შეუძლია ნებისმიერი რაოდენობის 
სამომხმარებლო სესხის ყოველთვიური შენატანის გამოთვლა, რის შედეგადაც მათ გაუმარტივდებათ მოვლენების დაგეგმარება,
რაც შესაბამისად გამოიწვევს მეტი ადამიანის დაინტერესებას და შემოსავლების ზრდას.
- **UI automation:** ავტომატიზაციით ჩვენ მარტივად შეგვიძლია გავტესტოთ ის ეტაპები, რასაც ნამდვილი მომხმარებელი 
გაივლის ყოველთვიური შენატანის სანახავად.

**E2E სცენარი - მისამართების გაფილტვრა ფილიალების მიხედვით**
- **Risk:** ტესტის წარუმატებლობის შემთხვევაში, მომხმარებლებს არ ექნებათ ბანკის ფილიალების და აპარატების 
მისამართების ნახვის შესაძლებლობა, რის გამოც შეიძლება გაუჭირდეთ მათი ქალაქში მიგნება.
- **Business value:** ფუნქციონალის დახმარებით, მომხმარებლებს შეეძლებათ მარტივად ნახონ ნებისმიერი ქალაქის 
ან რაიონის მომსახურების ფილიალი/აპარატი. რის შედეგადაც გაიზრდება ბანკის მომხმარებლების რაოდენობა.
- **UI automation:** ავტომატიზაციის დახმარებით ჩვენ შეგვიძლია დავწეროთ ისეთი კოდი, რომელიც იქნება
დინამიური, მარტივად მართვადი და რომლის დახმარებითაც მარტივად იქნება შესაძლებელი მისამართების ნახვის
ფუნქციონალის გატესტვა.

**E2E სცენარი - ფილიალების მოძებნა რაიონების მიხედვით**
- **Risk:** ტესტის დაფეილების შემთხვევაში მომხმარებლებს არ ექნებათ შესაძლებლობა ნახონ უახლოესი ფილიალები.
- **Business value:** აღნიშნული ფუნქციონალის დახმარებით მომხმარებლებს მარტივად შეეძლებათ ფილიალების
მოძებნა რაიონების მიხედვით და უახლოესის პოვნა, რაც გაამარტივებს მათ მიგნებას.
- **UI automation:** ავტომატიზაციის საშუალებით ჩვენ შეგვიძლია იმ ეტაპების გავლა რასაც რეალური მომხმარებელი
გაივლის სასურველი ფილიალის მოსაძებნად.


## Selector Strategy
სელექტორებისთვის ძირითადად გამოყენებულია xpath გამოსახულება:
**navItemForMyBusiness:** აღნიშნული სელექტორი ირჩევს ჰედერის ნავიგაციის ელემენტს, რომელსაც აწერია
"ჩემი ბიზნესისთვის". სელექტორი მოიცავს კლასის სახელს, რომელიც მხოლოდ ჰედერის ნავიგაციის ელემენტებს
აქვს და უნიკალურ ტექსტს, რომელიც ხშირად არ შეიცვლება. ხოლო თუ მომავალში აღნიშნულ ელემენტს გადაარქმევენ
სახელს ან შეუცვლიან კლასს, ლოკატორი შეიძლება გაფუჭდეს. 
**navToCurrenciesButton** ლოკატორში სელენაიდის ფილტრის და Condition.visible-ის დახმარებით ხდება 
ისეთი ელემენტების მოძიება რომლებიც დამალული არ არის. სტაბილურია რადგან უნიკალურ კლასებს და ტექსტს იყენებს.
მომავალში შესაძლებელია აღარ გამოდგეს თუ ნავიგაციის ელემენტს სახელს შეუცვლიან. პრიორიტეტი დაბალი id-სთან 
შედარებით.
**firstTenResultCards** ლოკატორი აბრუნებს რეზულტების ელემენტებს, მხოლოდ პირველ 10-ს position-ის გამოენებით
და უნიკალური კლასის დასახელებით. ლოკატორში გამოყენებულია contains ფუნქცია მაგრამ თუ კლასის ამ ნაწილის დასახელება
შეიცვლება შეიძლება აღარ იმუშაოს.  



## Flaky Test Awareness
ზოგი ტესტი ფეილდებოდა რადგან სელექტორებში ხშირად ვიყენებდი ისეთ მკაცრ მიდგომას, როგორიცაა 
@class="class-name", რაც იწვევდა elementNotFoundException-ს რადგან საიტზე ხდებოდა კლასების დინამიური
დაგენერირება და ინტერაქციის დროს ისინი იცვლებოდა, ამის გადასაჭრელად მომიწია contains(@class, 'class-name') 
მეთოდის გამოყენება.

ასევე შეთავაზებების გაფილტვრის ტესტ მეთოდზე შედეგების დალოდების გარეშე სელენაიდი ელემენტების წამოღებას ვერ 
მოასწრებდა, რისთვისაც გამოვიყენე cards.shouldHave(CollectionCondition.sizeGreaterThan(0)) მეთოდი, 
მაგრამ შემდეგ ზოგჯერ მაინც ფეილდებოდა საიტის სინელის გამო და 10ივე ქარდის წამოღებას ვერ ასწრებდა. მეთოდში ვერ 
გამოვიყენებდი ფისქირებულ რიცხვს, თუ გამოვიყენებდი და რიცხვზე ნაკლები შეთავაზება აღმოჩნდებოდა გვერდზე ტესტი 
დაფეილდებოდა. აქედან გამომდინარე საჭიროდ ჩავთვალე RetryAnalyzer-ის გამოყენება.

## Mobile ≠ Desktop
მობაილის შემთხვევაში აპლიკაციის გარკვეული სტეპების განხორციელება მომიწია განსხვავებულად, რისთვისაც
გამოვიყენე testng.xml ფაილი, რაც სცენარებს გაუშვებს პარალელურად მობაილისთვის და დესკტოპისთვის.
ზოგიერთი სტეპი და სელექტორი განსხვავებულად გავწერე მობაილის რეზოლუციის მოსარგებად (მაგ. 
burger bar მენიუ და მასზე დაკლიკება, რომელიც მხოლოდ მობაილის ვერსიაში გვხვდება).<br>
**UX რისკები მობაილზე**
- პატარა ეკრანის გამო გარკვეულმა ელემენტებმა შეიძლება სხვა ელემენტები გადაფაროს.
- მაგ. cookie-ის ნოთიფიკაცია, რომლისთვისაც ცალკე სტეპის დაწერა მომიწია დაკლიკებისთვის.
- რამაც შეიძლება გამოიწვიოს ტესტის დაფეილება ან არასასიამოვნო გამოცდილება დაუტოვოს მომხმარებელს.
